; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Documents and Settings\Jorge Fernandez\Desktop\Sistemas Operativos I\2016-ii-1272-so1-osdevseries-jorgefer00\tutorial17\SysCore\Kernel\exception.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG2681	DB	'Divide by 0 at physical address [0x%x:0x%x] EFLAGS [0x%x'
	DB	']', 00H
	ORG $+2
$SG2690	DB	'Single step at physical address [0x%x:0x%x] EFLAGS [0x%x'
	DB	']', 00H
	ORG $+2
$SG2699	DB	'NMI trap at physical address [0x%x:0x%x] EFLAGS [0x%x]', 00H
	ORG $+1
$SG2708	DB	'Breakpoint trap at physical address [0x%x:0x%x] EFLAGS ['
	DB	'0x%x]', 00H
	ORG $+2
$SG2717	DB	'Overflow trap at physical address [0x%x:0x%x] EFLAGS [0x'
	DB	'%x]', 00H
	ORG $+4
$SG2726	DB	'Bounds check fault at physical address [0x%x:0x%x] EFLAG'
	DB	'S [0x%x]', 00H
	ORG $+3
$SG2735	DB	'Invalid opcode at physical address [0x%x:0x%x] EFLAGS [0'
	DB	'x%x]', 00H
	ORG $+7
$SG2744	DB	'Device not found fault at physical address [0x%x:0x%x] E'
	DB	'FLAGS [0x%x]', 00H
	ORG $+3
$SG2754	DB	'Double fault at physical address [0x%x:0x%x] EFLAGS [0x%'
	DB	'x]', 00H
	ORG $+1
$SG2764	DB	'Invalid TSS at physical address [0x%x:0x%x] EFLAGS [0x%x'
	DB	']', 00H
	ORG $+2
$SG2774	DB	'Invalid segment at physical address [0x%x:0x%x] EFLAGS ['
	DB	'0x%x]', 00H
	ORG $+2
$SG2784	DB	'Stack fault at physical address [0x%x:0x%x] EFLAGS [0x%x'
	DB	']', 00H
	ORG $+6
$SG2794	DB	'General Protection Fault at physical address [0x%x:0x%x]'
	DB	' EFLAGS [0x%x]', 00H
	ORG $+1
$SG2805	DB	'Page Fault at 0x%x:0x%x refrenced memory at 0x%x', 00H
	ORG $+3
$SG2814	DB	'FPU Fault at physical address [0x%x:0x%x] EFLAGS [0x%x]', 00H
$SG2824	DB	'Alignment Check at physical address [0x%x:0x%x] EFLAGS ['
	DB	'0x%x]', 00H
	ORG $+2
$SG2833	DB	'Machine Check at physical address [0x%x:0x%x] EFLAGS [0x'
	DB	'%x]', 00H
$SG2842	DB	'FPU SIMD fault at physical address [0x%x:0x%x] EFLAGS [0'
	DB	'x%x]', 00H
CONST	ENDS
PUBLIC	?divide_by_zero_fault@@YAXIII@Z			; divide_by_zero_fault
EXTRN	?kernel_panic@@YAXPBDZZ:PROC			; kernel_panic
; Function compile flags: /Ogsp
; File c:\documents and settings\jorge fernandez\desktop\sistemas operativos i\2016-ii-1272-so1-osdevseries-jorgefer00\tutorial17\syscore\kernel\exception.cpp
;	COMDAT ?divide_by_zero_fault@@YAXIII@Z
_TEXT	SEGMENT
_eip$ = 8						; size = 4
_cs$ = 12						; size = 4
_flags$ = 16						; size = 4
?divide_by_zero_fault@@YAXIII@Z PROC			; divide_by_zero_fault, COMDAT

; 31   : void _cdecl divide_by_zero_fault (uint32_t eip, uint32_t cs, uint32_t flags) {

	push	ebp
	mov	ebp, esp

; 32   : 
; 33   : 	intstart ();

	cli
	sub	ebp, 4

; 34   : 	kernel_panic ("Divide by 0 at physical address [0x%x:0x%x] EFLAGS [0x%x]",cs,eip, flags);

	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2681
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@divide_by_:

; 35   : 	for (;;);

	jmp	SHORT $LL2@divide_by_
?divide_by_zero_fault@@YAXIII@Z ENDP			; divide_by_zero_fault
_TEXT	ENDS
PUBLIC	?single_step_trap@@YAXIII@Z			; single_step_trap
; Function compile flags: /Ogsp
;	COMDAT ?single_step_trap@@YAXIII@Z
_TEXT	SEGMENT
_cs$ = 8						; size = 4
_eip$ = 12						; size = 4
_flags$ = 16						; size = 4
?single_step_trap@@YAXIII@Z PROC			; single_step_trap, COMDAT

; 39   : void _cdecl single_step_trap (uint32_t cs, uint32_t eip, uint32_t flags) {

	push	ebp
	mov	ebp, esp

; 40   : 
; 41   : 	intstart ();

	cli
	sub	ebp, 4

; 42   : 	kernel_panic ("Single step at physical address [0x%x:0x%x] EFLAGS [0x%x]",cs,eip, flags);

	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2690
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@single_ste:

; 43   : 	for (;;);

	jmp	SHORT $LL2@single_ste
?single_step_trap@@YAXIII@Z ENDP			; single_step_trap
_TEXT	ENDS
PUBLIC	?nmi_trap@@YAXIII@Z				; nmi_trap
; Function compile flags: /Ogsp
;	COMDAT ?nmi_trap@@YAXIII@Z
_TEXT	SEGMENT
_cs$ = 8						; size = 4
_eip$ = 12						; size = 4
_flags$ = 16						; size = 4
?nmi_trap@@YAXIII@Z PROC				; nmi_trap, COMDAT

; 47   : void _cdecl nmi_trap (uint32_t cs, uint32_t eip, uint32_t flags) {

	push	ebp
	mov	ebp, esp

; 48   : 
; 49   : 	intstart ();

	cli
	sub	ebp, 4

; 50   : 	kernel_panic ("NMI trap at physical address [0x%x:0x%x] EFLAGS [0x%x]",cs,eip, flags);

	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2699
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@nmi_trap:

; 51   : 	for (;;);

	jmp	SHORT $LL2@nmi_trap
?nmi_trap@@YAXIII@Z ENDP				; nmi_trap
_TEXT	ENDS
PUBLIC	?breakpoint_trap@@YAXIII@Z			; breakpoint_trap
; Function compile flags: /Ogsp
;	COMDAT ?breakpoint_trap@@YAXIII@Z
_TEXT	SEGMENT
_cs$ = 8						; size = 4
_eip$ = 12						; size = 4
_flags$ = 16						; size = 4
?breakpoint_trap@@YAXIII@Z PROC				; breakpoint_trap, COMDAT

; 55   : void _cdecl breakpoint_trap (uint32_t cs, uint32_t eip, uint32_t flags) {

	push	ebp
	mov	ebp, esp

; 56   : 
; 57   : 	intstart ();

	cli
	sub	ebp, 4

; 58   : 	kernel_panic ("Breakpoint trap at physical address [0x%x:0x%x] EFLAGS [0x%x]",cs,eip, flags);

	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2708
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@breakpoint:

; 59   : 	for (;;);

	jmp	SHORT $LL2@breakpoint
?breakpoint_trap@@YAXIII@Z ENDP				; breakpoint_trap
_TEXT	ENDS
PUBLIC	?overflow_trap@@YAXIII@Z			; overflow_trap
; Function compile flags: /Ogsp
;	COMDAT ?overflow_trap@@YAXIII@Z
_TEXT	SEGMENT
_cs$ = 8						; size = 4
_eip$ = 12						; size = 4
_flags$ = 16						; size = 4
?overflow_trap@@YAXIII@Z PROC				; overflow_trap, COMDAT

; 63   : void _cdecl overflow_trap (uint32_t cs, uint32_t eip, uint32_t flags) {

	push	ebp
	mov	ebp, esp

; 64   : 
; 65   : 	intstart ();

	cli
	sub	ebp, 4

; 66   : 	kernel_panic ("Overflow trap at physical address [0x%x:0x%x] EFLAGS [0x%x]",cs,eip, flags);

	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2717
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@overflow_t:

; 67   : 	for (;;);

	jmp	SHORT $LL2@overflow_t
?overflow_trap@@YAXIII@Z ENDP				; overflow_trap
_TEXT	ENDS
PUBLIC	?bounds_check_fault@@YAXIII@Z			; bounds_check_fault
; Function compile flags: /Ogsp
;	COMDAT ?bounds_check_fault@@YAXIII@Z
_TEXT	SEGMENT
_cs$ = 8						; size = 4
_eip$ = 12						; size = 4
_flags$ = 16						; size = 4
?bounds_check_fault@@YAXIII@Z PROC			; bounds_check_fault, COMDAT

; 71   : void _cdecl bounds_check_fault (uint32_t cs, uint32_t  eip, uint32_t flags) {

	push	ebp
	mov	ebp, esp

; 72   : 
; 73   : 	intstart ();

	cli
	sub	ebp, 4

; 74   : 	kernel_panic ("Bounds check fault at physical address [0x%x:0x%x] EFLAGS [0x%x]",cs,eip, flags);

	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2726
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@bounds_che:

; 75   : 	for (;;);

	jmp	SHORT $LL2@bounds_che
?bounds_check_fault@@YAXIII@Z ENDP			; bounds_check_fault
_TEXT	ENDS
PUBLIC	?invalid_opcode_fault@@YAXIII@Z			; invalid_opcode_fault
; Function compile flags: /Ogsp
;	COMDAT ?invalid_opcode_fault@@YAXIII@Z
_TEXT	SEGMENT
_cs$ = 8						; size = 4
_eip$ = 12						; size = 4
_flags$ = 16						; size = 4
?invalid_opcode_fault@@YAXIII@Z PROC			; invalid_opcode_fault, COMDAT

; 79   : void _cdecl invalid_opcode_fault (uint32_t cs, uint32_t  eip, uint32_t flags) {

	push	ebp
	mov	ebp, esp

; 80   : 
; 81   : 	intstart ();

	cli
	sub	ebp, 4

; 82   : 	kernel_panic ("Invalid opcode at physical address [0x%x:0x%x] EFLAGS [0x%x]",cs,eip, flags);

	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2735
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@invalid_op:

; 83   : 	for (;;);

	jmp	SHORT $LL2@invalid_op
?invalid_opcode_fault@@YAXIII@Z ENDP			; invalid_opcode_fault
_TEXT	ENDS
PUBLIC	?no_device_fault@@YAXIII@Z			; no_device_fault
; Function compile flags: /Ogsp
;	COMDAT ?no_device_fault@@YAXIII@Z
_TEXT	SEGMENT
_cs$ = 8						; size = 4
_eip$ = 12						; size = 4
_flags$ = 16						; size = 4
?no_device_fault@@YAXIII@Z PROC				; no_device_fault, COMDAT

; 87   : void _cdecl no_device_fault (uint32_t cs, uint32_t eip, uint32_t flags) {

	push	ebp
	mov	ebp, esp

; 88   : 
; 89   : 	intstart ();

	cli
	sub	ebp, 4

; 90   : 	kernel_panic ("Device not found fault at physical address [0x%x:0x%x] EFLAGS [0x%x]",cs,eip, flags);

	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2744
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@no_device_:

; 91   : 	for (;;);

	jmp	SHORT $LL2@no_device_
?no_device_fault@@YAXIII@Z ENDP				; no_device_fault
_TEXT	ENDS
PUBLIC	?double_fault_abort@@YAXIIII@Z			; double_fault_abort
; Function compile flags: /Ogsp
;	COMDAT ?double_fault_abort@@YAXIIII@Z
_TEXT	SEGMENT
_eip$ = 8						; size = 4
_cs$ = 12						; size = 4
_flags$ = 16						; size = 4
_err$ = 20						; size = 4
?double_fault_abort@@YAXIIII@Z PROC			; double_fault_abort, COMDAT

; 95   : void _cdecl double_fault_abort (uint32_t eip,uint32_t cs,uint32_t flags,uint32_t err)  {

	push	ebp
	mov	ebp, esp

; 96   : 
; 97   : 	intstart ();

	cli
	sub	ebp, 4

; 98   : 	kernel_panic ("Double fault at physical address [0x%x:0x%x] EFLAGS [0x%x]",cs,eip, flags);

	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2754
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@double_fau:

; 99   : 	for (;;);

	jmp	SHORT $LL2@double_fau
?double_fault_abort@@YAXIIII@Z ENDP			; double_fault_abort
_TEXT	ENDS
PUBLIC	?invalid_tss_fault@@YAXIIII@Z			; invalid_tss_fault
; Function compile flags: /Ogsp
;	COMDAT ?invalid_tss_fault@@YAXIIII@Z
_TEXT	SEGMENT
_eip$ = 8						; size = 4
_cs$ = 12						; size = 4
_flags$ = 16						; size = 4
_err$ = 20						; size = 4
?invalid_tss_fault@@YAXIIII@Z PROC			; invalid_tss_fault, COMDAT

; 103  : void _cdecl invalid_tss_fault (uint32_t eip,uint32_t cs,uint32_t flags,uint32_t err) {

	push	ebp
	mov	ebp, esp

; 104  : 
; 105  : 	intstart ();

	cli
	sub	ebp, 4

; 106  : 	kernel_panic ("Invalid TSS at physical address [0x%x:0x%x] EFLAGS [0x%x]",cs,eip, flags);

	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2764
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@invalid_ts:

; 107  : 	for (;;);

	jmp	SHORT $LL2@invalid_ts
?invalid_tss_fault@@YAXIIII@Z ENDP			; invalid_tss_fault
_TEXT	ENDS
PUBLIC	?no_segment_fault@@YAXIIII@Z			; no_segment_fault
; Function compile flags: /Ogsp
;	COMDAT ?no_segment_fault@@YAXIIII@Z
_TEXT	SEGMENT
_eip$ = 8						; size = 4
_cs$ = 12						; size = 4
_flags$ = 16						; size = 4
_err$ = 20						; size = 4
?no_segment_fault@@YAXIIII@Z PROC			; no_segment_fault, COMDAT

; 111  : void _cdecl no_segment_fault (uint32_t eip,uint32_t cs,uint32_t flags,uint32_t err)  {

	push	ebp
	mov	ebp, esp

; 112  : 
; 113  : 	intstart ();

	cli
	sub	ebp, 4

; 114  : 	kernel_panic ("Invalid segment at physical address [0x%x:0x%x] EFLAGS [0x%x]",cs,eip, flags);

	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2774
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@no_segment:

; 115  : 	for (;;);

	jmp	SHORT $LL2@no_segment
?no_segment_fault@@YAXIIII@Z ENDP			; no_segment_fault
_TEXT	ENDS
PUBLIC	?stack_fault@@YAXIIII@Z				; stack_fault
; Function compile flags: /Ogsp
;	COMDAT ?stack_fault@@YAXIIII@Z
_TEXT	SEGMENT
_eip$ = 8						; size = 4
_cs$ = 12						; size = 4
_flags$ = 16						; size = 4
_err$ = 20						; size = 4
?stack_fault@@YAXIIII@Z PROC				; stack_fault, COMDAT

; 119  : void _cdecl stack_fault (uint32_t eip,uint32_t cs,uint32_t flags,uint32_t err)  {

	push	ebp
	mov	ebp, esp

; 120  : 
; 121  : 	intstart ();

	cli
	sub	ebp, 4

; 122  : 	kernel_panic ("Stack fault at physical address [0x%x:0x%x] EFLAGS [0x%x]",cs,eip, flags);

	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2784
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@stack_faul:

; 123  : 	for (;;);

	jmp	SHORT $LL2@stack_faul
?stack_fault@@YAXIIII@Z ENDP				; stack_fault
_TEXT	ENDS
PUBLIC	?general_protection_fault@@YAXIIII@Z		; general_protection_fault
; Function compile flags: /Ogsp
;	COMDAT ?general_protection_fault@@YAXIIII@Z
_TEXT	SEGMENT
_eip$ = 8						; size = 4
_cs$ = 12						; size = 4
_flags$ = 16						; size = 4
_err$ = 20						; size = 4
?general_protection_fault@@YAXIIII@Z PROC		; general_protection_fault, COMDAT

; 127  : void _cdecl general_protection_fault (uint32_t eip,uint32_t cs,uint32_t flags,uint32_t err)  {

	push	ebp
	mov	ebp, esp

; 128  : 
; 129  : 	intstart ();

	cli
	sub	ebp, 4

; 130  : 	kernel_panic ("General Protection Fault at physical address [0x%x:0x%x] EFLAGS [0x%x]",
; 131  : 		cs,cs, cs);

	push	DWORD PTR _cs$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2794
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@general_pr:

; 132  : 	for (;;);

	jmp	SHORT $LL2@general_pr
?general_protection_fault@@YAXIIII@Z ENDP		; general_protection_fault
_TEXT	ENDS
PUBLIC	?page_fault@@YAXIIII@Z				; page_fault
; Function compile flags: /Ogsp
;	COMDAT ?page_fault@@YAXIIII@Z
_TEXT	SEGMENT
_faultAddr$ = -4					; size = 4
_eip$ = 8						; size = 4
_cs$ = 12						; size = 4
_flags$ = 16						; size = 4
_err$ = 20						; size = 4
?page_fault@@YAXIIII@Z PROC				; page_fault, COMDAT

; 137  : void _cdecl page_fault (uint32_t eip,uint32_t cs,uint32_t flags,uint32_t err) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 138  : 
; 139  : 	intstart ();

	cli
	sub	ebp, 4

; 140  : 
; 141  : 	int faultAddr=0;

	and	DWORD PTR _faultAddr$[ebp], 0

; 142  : 
; 143  : 	_asm {
; 144  : 		mov eax, cr2

	mov	eax, cr2

; 145  : 		mov [faultAddr], eax

	mov	DWORD PTR _faultAddr$[ebp], eax

; 146  : 	}
; 147  : 
; 148  : 	kernel_panic ("Page Fault at 0x%x:0x%x refrenced memory at 0x%x",
; 149  : 		cs, eip, faultAddr);

	push	DWORD PTR _faultAddr$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2805
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@page_fault:

; 150  : 	for (;;);

	jmp	SHORT $LL2@page_fault
?page_fault@@YAXIIII@Z ENDP				; page_fault
_TEXT	ENDS
PUBLIC	?fpu_fault@@YAXIII@Z				; fpu_fault
; Function compile flags: /Ogsp
;	COMDAT ?fpu_fault@@YAXIII@Z
_TEXT	SEGMENT
_cs$ = 8						; size = 4
_eip$ = 12						; size = 4
_flags$ = 16						; size = 4
?fpu_fault@@YAXIII@Z PROC				; fpu_fault, COMDAT

; 155  : 
; 156  : 	intstart ();

	cli
	sub	ebp, 4

; 157  : 	kernel_panic ("FPU Fault at physical address [0x%x:0x%x] EFLAGS [0x%x]",cs,eip, flags);

	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2814
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@fpu_fault:

; 158  : 	for (;;);

	jmp	SHORT $LL2@fpu_fault
?fpu_fault@@YAXIII@Z ENDP				; fpu_fault
_TEXT	ENDS
PUBLIC	?alignment_check_fault@@YAXIIII@Z		; alignment_check_fault
; Function compile flags: /Ogsp
;	COMDAT ?alignment_check_fault@@YAXIIII@Z
_TEXT	SEGMENT
_eip$ = 8						; size = 4
_cs$ = 12						; size = 4
_flags$ = 16						; size = 4
_err$ = 20						; size = 4
?alignment_check_fault@@YAXIIII@Z PROC			; alignment_check_fault, COMDAT

; 163  : 
; 164  : 	intstart ();

	cli
	sub	ebp, 4

; 165  : 	kernel_panic ("Alignment Check at physical address [0x%x:0x%x] EFLAGS [0x%x]",cs,eip, flags);

	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2824
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@alignment_:

; 166  : 	for (;;);

	jmp	SHORT $LL2@alignment_
?alignment_check_fault@@YAXIIII@Z ENDP			; alignment_check_fault
_TEXT	ENDS
PUBLIC	?machine_check_abort@@YAXIII@Z			; machine_check_abort
; Function compile flags: /Ogsp
;	COMDAT ?machine_check_abort@@YAXIII@Z
_TEXT	SEGMENT
_cs$ = 8						; size = 4
_eip$ = 12						; size = 4
_flags$ = 16						; size = 4
?machine_check_abort@@YAXIII@Z PROC			; machine_check_abort, COMDAT

; 171  : 
; 172  : 	intstart ();

	cli
	sub	ebp, 4

; 173  : 	kernel_panic ("Machine Check at physical address [0x%x:0x%x] EFLAGS [0x%x]",cs,eip, flags);

	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2833
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@machine_ch:

; 174  : 	for (;;);

	jmp	SHORT $LL2@machine_ch
?machine_check_abort@@YAXIII@Z ENDP			; machine_check_abort
_TEXT	ENDS
PUBLIC	?simd_fpu_fault@@YAXIII@Z			; simd_fpu_fault
; Function compile flags: /Ogsp
;	COMDAT ?simd_fpu_fault@@YAXIII@Z
_TEXT	SEGMENT
_cs$ = 8						; size = 4
_eip$ = 12						; size = 4
_flags$ = 16						; size = 4
?simd_fpu_fault@@YAXIII@Z PROC				; simd_fpu_fault, COMDAT

; 179  : 
; 180  : 	intstart ();

	cli
	sub	ebp, 4

; 181  : 	kernel_panic ("FPU SIMD fault at physical address [0x%x:0x%x] EFLAGS [0x%x]",cs,eip, flags);

	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _eip$[ebp]
	push	DWORD PTR _cs$[ebp]
	push	OFFSET $SG2842
	call	?kernel_panic@@YAXPBDZZ			; kernel_panic
	add	esp, 16					; 00000010H
$LL2@simd_fpu_f:

; 182  : 	for (;;);

	jmp	SHORT $LL2@simd_fpu_f
?simd_fpu_fault@@YAXIII@Z ENDP				; simd_fpu_fault
_TEXT	ENDS
END
